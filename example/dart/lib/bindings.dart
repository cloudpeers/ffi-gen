// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by "ffi-gen".

library api;

import "dart:async";
import "dart:convert";
import "dart:ffi" as ffi;
import "dart:io" show Platform;
import "dart:isolate";
import "dart:typed_data";

ffi.Pointer<ffi.Void> _registerFinalizer(_Box boxed) {
  final dart = ffi.DynamicLibrary.executable();
  final registerPtr = dart.lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Handle, ffi.Pointer<ffi.Void>,
              ffi.IntPtr, ffi.Pointer<ffi.Void>)>>("Dart_NewFinalizableHandle");
  final register = registerPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          Object, ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();
  return register(boxed, boxed._ptr, 42, boxed._dropPtr.cast());
}

void _unregisterFinalizer(_Box boxed) {
  final dart = ffi.DynamicLibrary.executable();
  final unregisterPtr = dart.lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>,
              ffi.Handle)>>("Dart_DeleteFinalizableHandle");
  final unregister =
      unregisterPtr.asFunction<void Function(ffi.Pointer<ffi.Void>, _Box)>();
  unregister(boxed._finalizer, boxed);
}

class _Box {
  final Api _api;
  final ffi.Pointer<ffi.Void> _ptr;
  final String _dropSymbol;
  bool _dropped;
  bool _moved;
  ffi.Pointer<ffi.Void> _finalizer = ffi.Pointer.fromAddress(0);

  _Box(this._api, this._ptr, this._dropSymbol)
      : _dropped = false,
        _moved = false;

  late final _dropPtr = _api._lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(_dropSymbol);

  late final _drop = _dropPtr.asFunction<
      void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  int borrow() {
    if (_dropped) {
      throw StateError("use after free");
    }
    if (_moved) {
      throw StateError("use after move");
    }
    return _ptr.address;
  }

  int move() {
    if (_dropped) {
      throw StateError("use after free");
    }
    if (_moved) {
      throw StateError("can't move value twice");
    }
    _moved = true;
    _unregisterFinalizer(this);
    return _ptr.address;
  }

  void drop() {
    if (_dropped) {
      throw StateError("double free");
    }
    if (_moved) {
      throw StateError("can't drop moved value");
    }
    _dropped = true;
    _unregisterFinalizer(this);
    _drop(ffi.Pointer.fromAddress(0), _ptr);
  }
}

Future<T> _nativeFuture<T>(_Box box, T? Function(int, int, int) nativePoll) {
  final completer = Completer<T>();
  final rx = ReceivePort();
  void poll() {
    try {
      final ret = nativePoll(box.borrow(), ffi.NativeApi.postCObject.address,
          rx.sendPort.nativePort);
      if (ret == null) {
        return;
      }
      completer.complete(ret);
    } catch (err) {
      completer.completeError(err);
    }
    rx.close();
    box.drop();
  }

  rx.listen((dynamic _message) => poll());
  poll();
  return completer.future;
}

Stream<T> _nativeStream<T>(
    _Box box, T? Function(int, int, int, int) nativePoll) {
  final controller = StreamController<T>();
  final rx = ReceivePort();
  final done = ReceivePort();
  void poll() {
    try {
      final ret = nativePoll(
        box.borrow(),
        ffi.NativeApi.postCObject.address,
        rx.sendPort.nativePort,
        done.sendPort.nativePort,
      );
      if (ret != null) {
        controller.add(ret);
      }
    } catch (err) {
      controller.addError(err);
    }
  }

  rx.listen((dynamic _message) => poll());
  done.listen((dynamic _message) {
    rx.close();
    done.close();
    controller.close();
    box.drop();
  });
  poll();
  return controller.stream;
}

/// Main entry point to library.
class Api {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  Api(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  Api.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// The library is loaded from the executable.
  factory Api.loadStatic() {
    return Api(ffi.DynamicLibrary.executable());
  }

  /// The library is dynamically loaded.
  factory Api.loadDynamic(String name) {
    return Api(ffi.DynamicLibrary.open(name));
  }

  /// The library is loaded based on platform conventions.
  factory Api.load() {
    String? name;
    if (Platform.isLinux) name = "libapi.so";
    if (Platform.isAndroid) name = "libapi.so";
    if (Platform.isMacOS) name = "libapi.dylib";
    if (Platform.isIOS) name = "\"\"";
    if (Platform.isWindows) "api.dll";
    if (name == null) {
      throw UnsupportedError("\"This platform is not supported.\"");
    }
    if (name == "") {
      return Api.loadStatic();
    } else {
      return Api.loadDynamic(name);
    }
  }

  ffi.Pointer<T> __allocate<T extends ffi.NativeType>(
      int byteCount, int alignment) {
    return _allocate(byteCount, alignment).cast();
  }

  void __deallocate<T extends ffi.NativeType>(
      ffi.Pointer pointer, int byteCount, int alignment) {
    _deallocate(pointer.cast(), byteCount, alignment);
  }

  void helloWorld() {
    _helloWorld();
    return;
  }

  late final _allocatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Uint8> Function(ffi.IntPtr, ffi.IntPtr)>>("allocate");

  late final _allocate =
      _allocatePtr.asFunction<ffi.Pointer<ffi.Uint8> Function(int, int)>();

  late final _deallocatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Uint8>, ffi.IntPtr, ffi.IntPtr)>>("deallocate");

  late final _deallocate = _deallocatePtr
      .asFunction<void Function(ffi.Pointer<ffi.Uint8>, int, int)>();

  late final _helloWorldPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>("__hello_world");

  late final _helloWorld = _helloWorldPtr.asFunction<void Function()>();
}
