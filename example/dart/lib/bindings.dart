// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by "ffi-gen".

import "dart:async";
import "dart:convert";
import "dart:ffi" as ffi;
import "dart:io" show Platform;
import "dart:isolate";
import "dart:typed_data";

ffi.Pointer<ffi.Void> _registerFinalizer(Box boxed) {
  final dart = ffi.DynamicLibrary.executable();
  final registerPtr = dart.lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Handle, ffi.Pointer<ffi.Void>,
              ffi.IntPtr, ffi.Pointer<ffi.Void>)>>("Dart_NewFinalizableHandle");
  final register = registerPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          Object, ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();
  return register(boxed, boxed._ptr, 42, boxed._dropPtr.cast());
}

void _unregisterFinalizer(Box boxed) {
  final dart = ffi.DynamicLibrary.executable();
  final unregisterPtr = dart.lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>,
              ffi.Handle)>>("Dart_DeleteFinalizableHandle");
  final unregister =
      unregisterPtr.asFunction<void Function(ffi.Pointer<ffi.Void>, Box)>();
  unregister(boxed._finalizer, boxed);
}

class Box {
  final Api _api;
  final ffi.Pointer<ffi.Void> _ptr;
  final String _drop_symbol;
  bool _dropped;
  bool _moved;
  ffi.Pointer<ffi.Void> _finalizer = ffi.Pointer.fromAddress(0);

  Box(this._api, this._ptr, this._drop_symbol)
      : _dropped = false,
        _moved = false;

  late final _dropPtr = this._api._lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>>(this._drop_symbol);

  late final _drop = _dropPtr.asFunction<
      void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  int borrow() {
    if (this._dropped) {
      throw new StateError("use after free");
    }
    if (this._moved) {
      throw new StateError("use after move");
    }
    return this._ptr.address;
  }

  int move() {
    if (this._dropped) {
      throw new StateError("use after free");
    }
    if (this._moved) {
      throw new StateError("can't move value twice");
    }
    this._moved = true;
    _unregisterFinalizer(this);
    return this._ptr.address;
  }

  void drop() {
    if (this._dropped) {
      throw new StateError("double free");
    }
    if (this._moved) {
      throw new StateError("can't drop moved value");
    }
    this._dropped = true;
    _unregisterFinalizer(this);
    this._drop(ffi.Pointer.fromAddress(0), this._ptr);
  }
}

Future<T> _nativeFuture<T>(Box box, T? Function(int, int, int) nativePoll) {
  final completer = Completer<T>();
  final rx = ReceivePort();
  final poll = () {
    final ret = nativePoll(box.borrow(), ffi.NativeApi.postCObject.address,
        rx.sendPort.nativePort);
    if (ret != null) {
      rx.close();
      completer.complete(ret);
      box.drop();
    }
  };
  rx.listen((dynamic _message) => poll());
  poll();
  return completer.future;
}

Stream<T> _nativeStream<T>(
    Box box, T? Function(int, int, int, int) nativePoll) {
  final controller = StreamController<T>();
  final rx = ReceivePort();
  final done = ReceivePort();
  final poll = () {
    final ret = nativePoll(
      box.borrow(),
      ffi.NativeApi.postCObject.address,
      rx.sendPort.nativePort,
      done.sendPort.nativePort,
    );
    if (ret != null) {
      controller.add(ret);
    }
  };
  rx.listen((dynamic _message) => poll());
  done.listen((dynamic _message) {
    rx.close();
    done.close();
    controller.close();
    box.drop();
  });
  poll();
  return controller.stream;
}

class Api {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  Api(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  Api.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// The library is loaded from the executable.
  factory Api.loadStatic() {
    return Api(ffi.DynamicLibrary.executable());
  }

  /// The library is dynamically loaded.
  factory Api.loadDynamic(String name) {
    return Api(ffi.DynamicLibrary.open(name));
  }

  /// The library is loaded based on platform conventions.
  factory Api.load() {
    String? name;
    if (Platform.isLinux) name = "libapi.so";
    if (Platform.isAndroid) name = "libapi.so";
    if (Platform.isMacOS) name = "libapi.dylib";
    if (Platform.isIOS) name = "\"\"";
    if (Platform.isWindows) "api.dll";
    if (name == null) {
      throw UnsupportedError("\"This platform is not supported.\"");
    }
    if (name == "") {
      return Api.loadStatic();
    } else {
      return Api.loadDynamic(name);
    }
  }

  ffi.Pointer<T> allocate<T extends ffi.NativeType>(
      int byteCount, int alignment) {
    return _allocate(byteCount, alignment).cast();
  }

  void deallocate<T extends ffi.NativeType>(
      ffi.Pointer pointer, int byteCount, int alignment) {
    this._deallocate(pointer.cast(), byteCount, alignment);
  }

  void hello_world() {
    this.__hello_world();
    return;
  }

  late final _allocatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Uint8> Function(ffi.IntPtr, ffi.IntPtr)>>("allocate");

  late final _allocate =
      _allocatePtr.asFunction<ffi.Pointer<ffi.Uint8> Function(int, int)>();

  late final _deallocatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Uint8>, ffi.IntPtr, ffi.IntPtr)>>("deallocate");

  late final _deallocate =
      _deallocatePtr.asFunction<Function(ffi.Pointer<ffi.Uint8>, int, int)>();

  late final __hello_worldPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>("__hello_world");

  late final __hello_world = __hello_worldPtr.asFunction<void Function()>();
}
